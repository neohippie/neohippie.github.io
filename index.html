<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset=utf-8>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    
    <title>N E O H I P P I E</title>
    
    <style>
        body {
            color   : #000;
            margin  : 0px; 
            overflow: hidden; 
        }
    </style>
</head>

<body>
    <script src="js/lib/three.js/three.js">        </script>
    <script src="js/lib/three.js/OrbitControls.js"></script>
    <script src="js/lib/three.js/Mirror.js">       </script>
    <script src="js/lib/three.js/WaterShader.js">  </script>
    <script src="js/lib/three.js/Detector.js">     </script>
    
    <script src="js/loadTextures.js">              </script>
    
    <script>
    
        if (!Detector.webgl) {
            Detector.addGetWebGLMessage();
        }
        
        var camera, scene, renderer, water, water2;
        
        var worldWidth = 256, worldDepth = 256,
            worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;
            
        var textureAssets = [
            { property: 'waterNormals', file: 'textures/waternormals.jpg'       },
            { property: 'heightMap'   , file: 'textures/heightmap.jpg'          },
            { property: 'skybox'      , file: 'textures/skybox_la_night.png' }
        ];
            
        loadTextures(textureAssets, function(textures) {
            init(textures);
            animate();
        });
        
        function init(textures) {
        
            var container = document.createElement('div');
            document.body.appendChild(container);
            
            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            
            container.appendChild(renderer.domElement);
            
            camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.5, 3000000 );
            //camera.position.set(0, 1, 0);
            
            controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.enablePan = false;
            controls.minDistance = 1000.0;
            controls.maxDistance = 5000.0;
            controls.maxPolarAngle = Math.PI * 0.495;
            controls.target.set(0, 1, 0);
            
            scene = new THREE.Scene();
            
            // water

            var geometry = new THREE.PlaneBufferGeometry(20000, 20000, worldWidth-1, worldDepth-1);
            geometry.rotateX(-Math.PI/2);

            var data     = loadHeight(textures.heightMap.image)
            var vertices = geometry.attributes.position.array;

            for (var i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3) {
                vertices[j+1] = data[i] * 10;
            }            

            textures.waterNormals.wrapS = textures.waterNormals.wrapT = THREE.RepeatWrapping;

            water = new THREE.Water(renderer, camera, scene, {
                textureWidth:  256,
                textureHeight: 256,
                waterNormals: textures.waterNormals,
                alpha: 	0.8,
                sunDirection: new THREE.Vector3(1, 1, 1).normalize(),
                sunColor:   0xff9900,
                waterColor: 0xffffff,
                distortionScale: 50.0,
                fog: scene.fog != undefined
            });

            var mesh = new THREE.Mesh(geometry, water.material);
            mesh.position.set(3000, -8300, 3000);
            mesh.rotateY(-Math.PI/1.5);
            mesh.add(water);
            
            scene.add(mesh);
            
            water2 = new THREE.Water(renderer, camera, scene, {
                textureWidth:  1024,
                textureHeight: 1024,
                waterNormals: textures.waterNormals,
                alpha: 	1.0,
                sunDirection: new THREE.Vector3(-1, 1, -1).normalize(),
                sunColor:   0xffffff,
                waterColor: 0x000000,
                distortionScale: 50.0,
                fog: scene.fog != undefined
            });
            
            mirrorMesh = new THREE.Mesh(
                new THREE.PlaneBufferGeometry( 2000 * 500, 2000 * 500 ),
                water2.material
            );

            mirrorMesh.add( water2 );
            mirrorMesh.position.set(0, -6000, 0);
            mirrorMesh.rotation.x = - Math.PI * 0.5;
            scene.add( mirrorMesh );
            
            // skybox

            var cubeMap = new THREE.CubeTexture( [] );
            cubeMap.format = THREE.RGBFormat;

            var getSide = function ( x, y ) {

                var size = 1024;

                var canvas = document.createElement('canvas');
                canvas.width  = size;
                canvas.height = size;
                
                var context = canvas.getContext( '2d' );
                context.drawImage( textures.skybox.image, - x * size, - y * size );

                return canvas;
            };

            cubeMap.images[ 0 ] = getSide( 2, 1 ); // px
            cubeMap.images[ 1 ] = getSide( 0, 1 ); // nx
            cubeMap.images[ 2 ] = getSide( 1, 0 ); // py
            cubeMap.images[ 3 ] = getSide( 1, 2 ); // ny
            cubeMap.images[ 4 ] = getSide( 1, 1 ); // pz
            cubeMap.images[ 5 ] = getSide( 3, 1 ); // nz
            cubeMap.needsUpdate = true;
          
            var cubeShader = THREE.ShaderLib[ 'cube' ];
            cubeShader.uniforms[ 'tCube' ].value = cubeMap;

            var skyBoxMaterial = new THREE.ShaderMaterial( {
                fragmentShader: cubeShader.fragmentShader,
                vertexShader: cubeShader.vertexShader,
                uniforms: cubeShader.uniforms,
                depthWrite: false,
                side: THREE.BackSide
            } );

            var skyBox = new THREE.Mesh(
                new THREE.BoxGeometry( 1000000, 1000000, 1000000 ),
                skyBoxMaterial
            );

            scene.add( skyBox );

            window.addEventListener('resize', onWindowResize, false);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function loadHeight(img) {
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            
            canvas.width  = img.width;
            canvas.height = img.height;
            
            context.drawImage(img, 0, 0, img.width, img.height);
            
            var data = context.getImageData(0, 0, img.height, img.width).data;
            var normPixels = []

            for (var i = 0, n = data.length; i < n; i += 4) {
                normPixels.push((data[i] + data[i+1] + data[i+2]) / 3);
            }
            
            return normPixels;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            water.material.uniforms.time.value += 1.0 / 60.0;
            water2.material.uniforms.time.value += 1.0 / 60.0;
            controls.update();
            water.render();
            water2.render();
            renderer.render(scene, camera);
        }
        
    </script>
</body>

</html>
