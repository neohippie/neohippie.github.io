<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset=utf-8>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    
    <title>N E O H I P P I E</title>
    
    <style>
        body {
            color   : #000;
            margin  : 0px; 
            overflow: hidden; 
        }
    </style>
</head>

<body>
    <script src="js/lib/three.js/three.js">        </script>
    <script src="js/lib/three.js/OrbitControls.js"></script>
    <script src="js/lib/three.js/Mirror.js">       </script>
    <script src="js/lib/three.js/WaterShader.js">  </script>
    <script src="js/lib/three.js/OBJLoader.js">    </script>
    <script src="js/lib/three.js/Detector.js">     </script>
    
    <script src="js/loadTextures.js">              </script>
    
    <script>
    
        if (!Detector.webgl) {
            Detector.addGetWebGLMessage();
        }
        
        window.addEventListener('resize', onWindowResize, false);
        
        var camera, scene, renderer;
        var oceanWater;
        var islandGeometry, islandVertices, islandClone;
        
        var worldWidth = 256, worldDepth = 256,
            worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;
            
        var textureAssets = [
            { property: 'waterNormals', file: 'textures/waternormals.jpg'       },
            { property: 'heightMap'   , file: 'textures/island_heightmap.jpg'   },
            { property: 'sand'        , file: 'textures/sand.png'               }
        ];
            
        loadTextures(textureAssets, function(textures) {
            init(textures);
            animate();
        });
        
        function init(textures) {
        
            var container = document.createElement('div');
            document.body.appendChild(container);
            
            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            container.appendChild(renderer.domElement);
            
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.5, 3000000);
            camera.position.set(980.6899010596237, 29.60587836256858, -193.4658152822133);
            
            controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.enablePan = false;
            controls.minDistance = 1000.0;
            controls.maxDistance = 5000.0;
            controls.maxPolarAngle = Math.PI * 0.495;
            controls.target.set(0, 1, 0);
            
            scene = new THREE.Scene();
            
            // light

            var sun = new THREE.DirectionalLight(0xff9933, 1);
            sun.position.set(-21500, 1000, -10000);
            
            scene.add(sun);
            scene.add(new THREE.AmbientLight(0x444444));
            
            /*var geometry = new THREE.BoxGeometry(100, 100, 100 ;
            var material = new THREE.MeshBasicMaterial({color: 0x00ff00});
            var cube     = new THREE.Mesh(geometry, material);
            cube.position.set(-21500, 1000, -10000);
            scene.add(cube);*/
            
            // island

            islandGeometry = new THREE.PlaneBufferGeometry(50000, 50000, worldWidth-1, worldDepth-1);
            islandGeometry.rotateX(-Math.PI/2);

            var islandData = loadHeight(textures.heightMap.image)
            islandVertices = islandGeometry.attributes.position.array;

            for (var i = 0, j = 0, l = islandVertices.length; i < l; i++, j += 3) {
                islandVertices[j+1] = islandData[i] * 10.0;
            }
            
            islandClone = islandVertices.slice();

            textures.sand.wrapS    = textures.sand.wrapT    = THREE.RepeatWrapping;
            textures.sand.repeat.x = textures.sand.repeat.y = 3;
            
            var islandMaterial = new THREE.MeshLambertMaterial( { 
                map: textures.sand, 
                polygonOffset: true,
                polygonOffsetFactor: -4 
            });

            var islandMesh = new THREE.Mesh(islandGeometry, islandMaterial);
            
            islandMesh.position.set(-20000, -6200, 0);
            islandMesh.rotateY(-Math.PI/1.5);
            
            scene.add(islandMesh);
            
            // ocean
            
            textures.waterNormals.wrapS = textures.waterNormals.wrapT = THREE.RepeatWrapping;
            
            oceanWater = new THREE.Water(renderer, camera, scene, {
                textureWidth:  1024,
                textureHeight: 1024,
                waterNormals: textures.waterNormals,
                alpha: 	0.7,
                sunDirection: sun.position.clone().normalize(),
                sunColor:     sun.color,
                waterColor: 0x001e0f,
                distortionScale: 50.0,
                fog: scene.fog != undefined
            });
            
            oceanMesh = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(1000000, 1000000),
                oceanWater.material
            );

            oceanMesh.add(oceanWater);
            oceanMesh.position.set(0, -6000, 0);
            oceanMesh.rotation.x = -Math.PI * 0.5;
            
            scene.add(oceanMesh);
            
            // skybox
            
            var urls = [
                'textures/SunSetLeft2048.png' , 'textures/SunSetRight2048.png',
                'textures/SunSetUp2048.png'   , 'textures/SunSetDown2048.png' ,
                'textures/SunSetFront2048.png', 'textures/SunSetBack2048.png'
            ];

            var cubeMap = new THREE.CubeTextureLoader().load(urls);
            
            cubeMap.format      = THREE.RGBFormat;
            cubeMap.needsUpdate = true;
          
            var cubeShader = THREE.ShaderLib['cube'];
            cubeShader.uniforms['tCube'].value = cubeMap;

            var skyBoxMaterial = new THREE.ShaderMaterial( {
                fragmentShader: cubeShader.fragmentShader,
                vertexShader: cubeShader.vertexShader,
                uniforms: cubeShader.uniforms,
                depthWrite: false,
                side: THREE.BackSide
            });

            var skyBox = new THREE.Mesh(
                new THREE.BoxGeometry(1000000, 1000000, 1000000),
                skyBoxMaterial
            );

            scene.add(skyBox);
            
            // city
            
            var objLoader = new THREE.OBJLoader();
            
            objLoader.load('models/la_osm.obj', function (model) {
                model.scale   .set(  10000,  10000,   10000);
                model.position.set(-900000, -10000, 1000000);
                
                scene.add(model);
            });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function loadHeight(img) {
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            
            canvas.width  = img.width;
            canvas.height = img.height;
            
            context.drawImage(img, 0, 0, img.width, img.height);
            
            var data = context.getImageData(0, 0, img.height, img.width).data;
            var normPixels = []

            for (var i = 0, n = data.length; i < n; i += 4) {
                normPixels.push((data[i] + data[i+1] + data[i+2]) / 3);
            }
            
            return normPixels;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        var WATER_LEVEL = 400.0;
        var WATER_RATE  = 0.001;

        function render() {
            
            // simulate tide by lowering edges of island
            for (var i = 0, j = 0; i < islandVertices.length; i++, j += 3) {
            
                var curLevel  = islandVertices[j+1];
                var baseLevel = islandClone   [j+1];
                
                if (baseLevel <= WATER_LEVEL && baseLevel > 0) {
                    
                    var theta     = WATER_RATE  * performance.now();
                    var amplitude = WATER_LEVEL / baseLevel;
                    
                    var test = Math.sin  (theta)            * amplitude
                       +  (1 - Math.abs(((theta) % 4) - 2)) * amplitude; // sawtooth
                    
                    if (curLevel+test < baseLevel) {
                        islandVertices[j+1] += test;
                    }
                }
            }
            
            islandGeometry.attributes.position.needsUpdate = true;
            oceanWater.material.uniforms.time.value += 1.0 / 60.0;
            
            controls.update();
            renderer.clear();
            
            oceanWater.render();
            renderer  .render(scene, camera);
        }
        
    </script>
</body>

</html>
