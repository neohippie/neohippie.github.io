<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset=utf-8>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    
    <title>N E O H I P P I E</title>
    
    <style>
        body {
            color   : #000;
            margin  : 0px; 
            overflow: hidden; 
        }
    </style>
</head>

<body>
    <script src="js/lib/three.js/three.js">        </script>
    <script src="js/lib/three.js/OrbitControls.js"></script>
    <script src="js/lib/three.js/Mirror.js">       </script>
    <script src="js/lib/three.js/WaterShader.js">  </script>
    <script src="js/lib/three.js/OBJLoader.js">    </script>
    <script src="js/lib/three.js/Detector.js">     </script>
    
    <script src="js/loadTextures.js">              </script>
    
    <script>
    
        if (!Detector.webgl) {
            Detector.addGetWebGLMessage();
        }
        
        window.addEventListener('resize', onWindowResize, false);
        
        var camera, scene, renderer;
        var textWater, oceanWater;
        
        var worldWidth = 256, worldDepth = 256,
            worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;
            
        var textureAssets = [
            { property: 'waterNormals', file: 'textures/waternormals.jpg'       },
            { property: 'heightMap'   , file: 'textures/heightmap.jpg'          },
            { property: 'skybox'      , file: 'textures/skybox_la_night.png'    }
        ];
            
        loadTextures(textureAssets, function(textures) {
            init(textures);
            animate();
        });
        
        function init(textures) {
        
            var container = document.createElement('div');
            document.body.appendChild(container);
            
            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            container.appendChild(renderer.domElement);
            
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.5, 3000000);
            
            controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.enablePan = false;
            controls.minDistance = 1000.0;
            controls.maxDistance = 5000.0;
            controls.maxPolarAngle = Math.PI * 0.495;
            controls.target.set(0, 1, 0);
            
            scene = new THREE.Scene();
            
            // text

            var textGeometry = new THREE.PlaneBufferGeometry(20000, 20000, worldWidth-1, worldDepth-1);
            textGeometry.rotateX(-Math.PI/2);

            var textData     = loadHeight(textures.heightMap.image)
            var textVertices = textGeometry.attributes.position.array;

            for (var i = 0, j = 0, l = textVertices.length; i < l; i ++, j += 3) {
                textVertices[j+1] = textData[i] * 10;
            }            

            textures.waterNormals.wrapS = textures.waterNormals.wrapT = THREE.RepeatWrapping;

            textWater = new THREE.Water(renderer, camera, scene, {
                textureWidth:  256,
                textureHeight: 256,
                waterNormals: textures.waterNormals,
                alpha: 	0.8,
                sunDirection: new THREE.Vector3(1, 1, 1).normalize(),
                sunColor:   0xff9900,
                waterColor: 0xffffff,
                distortionScale: 50.0,
                fog: scene.fog != undefined
            });

            var textMesh = new THREE.Mesh(textGeometry, textWater.material);
            textMesh.position.set(3000, -8300, 3000);
            textMesh.rotateY(-Math.PI/1.5);
            textMesh.add(textWater);
            
            scene.add(textMesh);
            
            // ocean
            
            oceanWater = new THREE.Water(renderer, camera, scene, {
                textureWidth:  1024,
                textureHeight: 1024,
                waterNormals: textures.waterNormals,
                alpha: 	1.0,
                sunDirection: new THREE.Vector3(-1, 1, -1).normalize(),
                sunColor:   0xff9933,
                waterColor: 0x001e0f,
                distortionScale: 50.0,
                fog: scene.fog != undefined
            });
            
            oceanMesh = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(1000000, 1000000),
                oceanWater.material
            );

            oceanMesh.add(oceanWater);
            oceanMesh.position.set(0, -6000, 0);
            oceanMesh.rotation.x = -Math.PI * 0.5;
            
            scene.add(oceanMesh);
            
            var urls = [
                'textures/SunSetLeft2048.png', 'textures/SunSetRight2048.png',
                'textures/SunSetUp2048.png'  , 'textures/SunSetDown2048.png' ,
                'textures/SunSetFront2048.png', 'textures/SunSetBack2048.png',
            ];

            var cubeMap = new THREE.CubeTextureLoader().load(urls);
            cubeMap.format = THREE.RGBFormat;
            
            var objLoader = new THREE.OBJLoader();
            objLoader.load('models/TheCity.obj', function (model) {
                model.scale.set(100, 100, 100);
                model.position.set(1000000, -10000, 0);
                scene.add(model);
            });
            
            // skybox

            /*var cubeMap = new THREE.CubeTexture( [] );
            cubeMap.format = THREE.RGBFormat;

            var getSide = function (x, y) {
                var size = 1024;
                var canvas = document.createElement('canvas');
                
                canvas.width  = size;
                canvas.height = size;
                
                var context = canvas.getContext('2d');
                context.drawImage(textures.skybox.image, -x * size, -y * size);

                return canvas;
            };

            cubeMap.images[0] = getSide(2, 1); // px
            cubeMap.images[1] = getSide(0, 1); // nx
            cubeMap.images[2] = getSide(1, 0); // py
            cubeMap.images[3] = getSide(1, 2); // ny
            cubeMap.images[4] = getSide(1, 1); // pz
            cubeMap.images[5] = getSide(3, 1); // nz*/
            
            cubeMap.needsUpdate = true;
          
            var cubeShader = THREE.ShaderLib['cube'];
            cubeShader.uniforms['tCube'].value = cubeMap;

            var skyBoxMaterial = new THREE.ShaderMaterial( {
                fragmentShader: cubeShader.fragmentShader,
                vertexShader: cubeShader.vertexShader,
                uniforms: cubeShader.uniforms,
                depthWrite: false,
                side: THREE.BackSide
            });

            var skyBox = new THREE.Mesh(
                new THREE.BoxGeometry(1000000, 1000000, 1000000),
                skyBoxMaterial
            );

            scene.add(skyBox);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function loadHeight(img) {
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            
            canvas.width  = img.width;
            canvas.height = img.height;
            
            context.drawImage(img, 0, 0, img.width, img.height);
            
            var data = context.getImageData(0, 0, img.height, img.width).data;
            var normPixels = []

            for (var i = 0, n = data.length; i < n; i += 4) {
                normPixels.push((data[i] + data[i+1] + data[i+2]) / 3);
            }
            
            return normPixels;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            textWater .material.uniforms.time.value += 1.0 / 60.0;
            oceanWater.material.uniforms.time.value += 1.0 / 60.0;
            
            controls.update();
            
            textWater .render();
            oceanWater.render();
            
            renderer.render(scene, camera);
        }
        
    </script>
</body>

</html>
