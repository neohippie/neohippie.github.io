<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset=utf-8>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    
    <title>N E O H I P P I E</title>
    
    <style>
        body {
            color   : #000;
            margin  : 0px; 
            overflow: hidden; 
        }
    </style>
</head>

<body>
    <script src="js/lib/three.js/three.js">        </script>
    <script src="js/lib/three.js/OrbitControls.js"></script>
    <script src="js/lib/three.js/Mirror.js">       </script>
    <script src="js/lib/three.js/WaterShader.js">  </script>
    <script src="js/lib/three.js/OBJLoader.js">    </script>
    <script src="js/lib/three.js/Detector.js">     </script>
    <script src="js/lib/three.js/ImageUtils.js">   </script>
    
    <script src="js/loadTextures.js">              </script>
    
    <style>
        body {
            background-color: black;
        }
        #container {
            //filter: saturate(120%);
            //-webkit-mask-image: radial-gradient(50% 50%, black 50%, rgba(0,0,0,0.4) 100%);
        }
    </style>
    
    <script>
    
        if (!Detector.webgl) {
            Detector.addGetWebGLMessage();
        }
        
        window.addEventListener('resize', onWindowResize, false);
        
        var camera, scene, renderer;
        var oceanWater;
        var islandGeometry, islandVertices, islandClone;
        
        var worldWidth = 512, worldDepth = 512,
            worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;
            
        var themeColor = new THREE.Color(0xFEF10C);
            
        var textureAssets = [
            { property: 'waterNormals', file: 'textures/waternormals.jpg'          },
            { property: 'heightMap'   , file: 'textures/island_heightmap_text.jpg' },
            { property: 'sand'        , file: 'textures/sand.png'                  },
        ];
            
        loadTextures(textureAssets, function(textures) {
            init(textures);
            animate();
        });
        
        function init(textures) {
        
            var container = document.createElement('div');
            container.id  = "container";
            
            document.body.appendChild(container);
            
            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            container.appendChild(renderer.domElement);
            
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.5, 3000000);
            camera.position.set(980.6899010596237, 29.60587836256858, -193.4658152822133);
            
            controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.enablePan = false;
            controls.minDistance = 1000.0;
            controls.maxDistance = 5000.0;
            controls.maxPolarAngle = Math.PI * 0.495;
            controls.target.set(0, 1, 0);
            
            scene = new THREE.Scene();
            
            // light

            var sun = new THREE.DirectionalLight(themeColor, 1);
            sun.position.set(-21500, 1000, -10000);
            
            scene.add(sun);
            scene.add(new THREE.AmbientLight(0x444444, 0.3));
            
            // island

            islandGeometry = new THREE.PlaneBufferGeometry(50000, 50000, worldWidth-1, worldDepth-1);
            islandGeometry.rotateX(-Math.PI/2);

            var islandData = loadHeight(textures.heightMap.image)
            islandVertices = islandGeometry.attributes.position.array;

            for (var i = 0, j = 0, l = islandVertices.length; i < l; i++, j += 3) {
                islandVertices[j+1] = islandData[i] * 20.0;
            }
            
            islandClone = islandVertices.slice();

            textures.sand.wrapS    = textures.sand.wrapT    = THREE.RepeatWrapping;
            textures.sand.repeat.x = textures.sand.repeat.y = 3;
            
            var islandMaterial = new THREE.MeshLambertMaterial( { 
                map: textures.sand, 
                polygonOffset: true,
                polygonOffsetFactor: 1.0
            });

            var islandMesh = new THREE.Mesh(islandGeometry, islandMaterial);
            
            islandMesh.position.set(-10000, -7000, 9000);
            islandMesh.rotateY(Math.PI/2.2);
            
            scene.add(islandMesh);
            
            // ocean
            
            textures.waterNormals.wrapS = textures.waterNormals.wrapT = THREE.RepeatWrapping;
            
            oceanWater = new THREE.Water(renderer, camera, scene, {
                textureWidth:  512,
                textureHeight: 512,
                waterNormals: textures.waterNormals,
                alpha: 	1.0,
                
                waterColor: themeColor, //0x001e0f,
                distortionScale: 50.0,
                fog: scene.fog != undefined
            });
            
            oceanMesh = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(1000000, 1000000),
                oceanWater.material
            );

            oceanMesh.add(oceanWater);
            oceanMesh.position.set(0, -6000, 0);
            oceanMesh.rotation.x = -Math.PI * 0.5;
            
            scene.add(oceanMesh);
            
            // skybox
            
            var skyTexture = THREE.ImageUtils.generateDataTexture(1, 1, themeColor);
            var skyImages = Array(6).fill(skyTexture);
            
            var cubeMap = new THREE.CubeTexture(skyImages);
            
            cubeMap.format      = THREE.RGBFormat;
            cubeMap.needsUpdate = true;
          
            var cubeShader = THREE.ShaderLib['cube'];
            cubeShader.uniforms['tCube'].value = cubeMap;

            var skyBoxMaterial = new THREE.ShaderMaterial( {
                fragmentShader: cubeShader.fragmentShader,
                vertexShader: cubeShader.vertexShader,
                uniforms: cubeShader.uniforms,
                depthWrite: false,
                side: THREE.BackSide
            });

            var skyBox = new THREE.Mesh(
                new THREE.BoxGeometry(1000000, 1000000, 1000000),
                skyBoxMaterial
            );

            scene.add(skyBox);
            
            // city
            
            var objLoader = new THREE.OBJLoader();
            
            objLoader.load('models/la_osm.obj', function (model) {
                model.scale   .set(  10000,  10000,   10000);
                model.position.set(-300000, -12000, 400000);
                model.rotation.y = -Math.PI * 0.5;
                
                scene.add(model);
            });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function loadHeight(img) {
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            
            canvas.width  = img.width;
            canvas.height = img.height;
            
            context.drawImage(img, 0, 0, img.width, img.height);
            
            var data = context.getImageData(0, 0, img.height, img.width).data;
            var normPixels = []

            for (var i = 0, n = data.length; i < n; i += 4) {
                normPixels.push((data[i] + data[i+1] + data[i+2]) / 3);
            }
            
            return normPixels;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        var WATER_LEVEL = 1100.0;
        var WATER_RATE  = 0.001;

        function render() {
            
            // simulate tide by lowering edges of island
            for (var i = 0, j = 0; i < islandVertices.length; i++, j += 3) {
            
                var curLevel  = islandVertices[j+1];
                var baseLevel = islandClone   [j+1];
                
                if (baseLevel <= WATER_LEVEL && baseLevel > 0) {
                    
                    var theta     = WATER_RATE  * performance.now();
                    var amplitude = WATER_LEVEL / baseLevel;
                    
                    var test = Math.sin  (theta)            * amplitude
                       +  (1 - Math.abs(((theta) % 4) - 2)) * amplitude; // sawtooth
                    
                    if (curLevel+test < baseLevel) {
                        islandVertices[j+1] += test;
                    }
                }
            }
            
            islandGeometry.attributes.position.needsUpdate = true;
            oceanWater.material.uniforms.time.value -= 1.0 / 30.0;
            
            controls.update();
            renderer.clear();
            
            oceanWater.render();
            renderer  .render(scene, camera);
        }
        
    </script>
</body>

</html>
